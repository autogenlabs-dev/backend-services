"""
Extension Authentication API endpoints - Clerk-compatible API for VS Code extension.

This module implements Clerk-like API endpoints that the VS Code extension expects.
The extension uses these endpoints for OAuth authentication flow.

Flow:
1. Extension opens /extension/sign-in with state and auth_redirect
2. Backend redirects to Google OAuth
3. Google redirects back to /api/auth/google/callback with code
4. Backend generates a ticket and redirects to extension with ticket
5. Extension exchanges ticket at /v1/client/sign_ins for clientToken and sessionId
6. Extension uses clientToken to get JWT at /v1/client/sessions/{sessionId}/tokens
7. Extension uses JWT to call APIs
"""

from datetime import datetime, timedelta
from typing import Optional
import secrets
import json

from fastapi import APIRouter, Depends, HTTPException, Request, Form, Header
from fastapi.responses import RedirectResponse, JSONResponse
from motor.motor_asyncio import AsyncIOMotorDatabase
from pydantic import BaseModel

from ..database import get_database, get_redis
from ..auth.jwt import create_access_token, verify_token
from ..auth.oauth import oauth, register_oauth_clients
from ..services.user_service import get_or_create_user_by_oauth, update_user_last_login, get_user_by_id
from ..config import settings
from beanie import PydanticObjectId

router = APIRouter(tags=["Extension Authentication"])


class SignInRequest(BaseModel):
    """Request model for sign-in with ticket."""
    strategy: str  # Should be "ticket"
    ticket: str  # The authorization ticket from OAuth callback


class SignInResponse(BaseModel):
    """Response model for sign-in."""
    response: dict  # Contains created_session_id


class SessionTokenResponse(BaseModel):
    """Response model for session token creation."""
    jwt: str  # The JWT token


class UserInfoResponse(BaseModel):
    """Response model for user information."""
    response: dict  # Contains user data


class OrganizationMembershipsResponse(BaseModel):
    """Response model for organization memberships."""
    response: list  # List of organization memberships


@router.get("/extension/sign-in")
async def extension_sign_in(
    request: Request,
    state: str,
    auth_redirect: str,
    redis_client = Depends(get_redis)
):
    """
    Extension sign-in initiation endpoint.
    
    This endpoint is called by the VS Code extension to start the OAuth flow.
    It redirects to Google OAuth with the state parameter.
    
    Parameters:
    - state: CSRF protection token generated by the extension
    - auth_redirect: The VS Code URI scheme to redirect back to (e.g., vscode://publisher.extension)
    
    Flow:
    1. Store auth_redirect with state in Redis
    2. Redirect to Google OAuth with state parameter
    3. After OAuth, callback will use state to find auth_redirect
    """
    try:
        # Ensure OAuth client is properly initialized
        if not oauth.google:
            register_oauth_clients()
        
        if not oauth.google:
            raise HTTPException(
                status_code=500,
                detail="Google OAuth client is not available"
            )
        
        # Store extension callback info in Redis (10 minute expiry)
        extension_data = {
            "auth_redirect": auth_redirect,
            "source": "extension",
            "created_at": datetime.utcnow().isoformat()
        }
        redis_client.setex(
            f"extension:auth:{state}",
            600,  # 10 minutes
            json.dumps(extension_data)
        )
        
        # Redirect to Google OAuth
        redirect_uri = settings.google_redirect_uri
        return await oauth.google.authorize_redirect(request, redirect_uri, state=state)
        
    except Exception as e:
        print(f"Extension sign-in error: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(
            status_code=500,
            detail=f"Failed to initiate extension sign-in: {str(e)}"
        )


@router.post("/v1/client/sign_ins")
async def client_sign_ins(
    strategy: str = Form(...),
    ticket: str = Form(...),
    redis_client = Depends(get_redis),
    db: AsyncIOMotorDatabase = Depends(get_database)
):
    """
    Exchange authorization ticket for client token and session ID.
    
    This endpoint is called by the VS Code extension after receiving the ticket
    from the OAuth callback redirect.
    
    Parameters:
    - strategy: Authentication strategy (should be "ticket")
    - ticket: The authorization ticket from OAuth callback
    
    Returns:
    - response: Contains created_session_id
    - Authorization header: Contains the client token (Bearer token)
    """
    try:
        # Validate strategy
        if strategy != "ticket":
            raise HTTPException(
                status_code=400,
                detail="Invalid strategy. Must be 'ticket'"
            )
        
        # Retrieve ticket data from Redis
        ticket_key = f"extension:ticket:{ticket}"
        ticket_data_str = redis_client.get(ticket_key)
        
        if not ticket_data_str:
            raise HTTPException(
                status_code=400,
                detail="Invalid or expired ticket"
            )
        
        # Parse ticket data
        ticket_data = json.loads(ticket_data_str)
        user_id = ticket_data.get("user_id")
        email = ticket_data.get("email")
        
        if not user_id:
            raise HTTPException(
                status_code=400,
                detail="Invalid ticket data"
            )
        
        # Get user from database
        try:
            user_obj_id = PydanticObjectId(user_id)
        except Exception:
            raise HTTPException(
                status_code=400,
                detail="Invalid user ID format"
            )
        
        user = await get_user_by_id(db, user_obj_id)
        if not user or not user.is_active:
            raise HTTPException(
                status_code=401,
                detail="User not found or inactive"
            )
        
        # Generate client token (long-lived JWT)
        client_token = create_access_token(
            data={
                "sub": str(user.id),
                "email": user.email,
                "type": "client"
            },
            expires_delta=timedelta(days=365)  # Long-lived for extension
        )
        
        # Generate session ID
        session_id = secrets.token_urlsafe(32)
        
        # Store session data in Redis (30 days expiry)
        session_data = {
            "user_id": str(user.id),
            "email": user.email,
            "created_at": datetime.utcnow().isoformat()
        }
        redis_client.setex(
            f"extension:session:{session_id}",
            2592000,  # 30 days
            json.dumps(session_data)
        )
        
        # Delete used ticket (one-time use)
        redis_client.delete(ticket_key)
        
        # Update last login
        if user.id:
            await update_user_last_login(db, user.id)
        
        # Return response with Authorization header containing client token
        response = JSONResponse(
            content={
                "response": {
                    "created_session_id": session_id
                }
            }
        )
        response.headers["Authorization"] = f"Bearer {client_token}"
        
        return response
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"Sign-in error: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(
            status_code=500,
            detail="Failed to exchange ticket for session"
        )


@router.post("/v1/client/sessions/{session_id}/tokens")
async def create_session_token(
    session_id: str,
    authorization: Optional[str] = Header(None),
    redis_client = Depends(get_redis),
    db: AsyncIOMotorDatabase = Depends(get_database)
):
    """
    Create a JWT session token from client token.
    
    This endpoint is called by the VS Code extension to get short-lived JWT tokens
    using the long-lived client token.
    
    Parameters:
    - session_id: The session ID from sign_ins response
    - Authorization header: Bearer {client_token}
    
    Returns:
    - jwt: Short-lived JWT token for API access
    """
    try:
        # Extract and verify client token from Authorization header
        if not authorization or not authorization.startswith("Bearer "):
            raise HTTPException(
                status_code=401,
                detail="Missing or invalid authorization header"
            )
        
        client_token = authorization.replace("Bearer ", "")
        
        # Verify client token
        token_payload = verify_token(client_token)
        if not token_payload or token_payload.get("type") != "client":
            raise HTTPException(
                status_code=401,
                detail="Invalid client token"
            )
        
        user_id = token_payload.get("sub")
        if not user_id:
            raise HTTPException(
                status_code=401,
                detail="Invalid token payload"
            )
        
        # Verify session exists
        session_key = f"extension:session:{session_id}"
        session_data_str = redis_client.get(session_key)
        
        if not session_data_str:
            raise HTTPException(
                status_code=401,
                detail="Invalid or expired session"
            )
        
        # Parse session data
        session_data = json.loads(session_data_str)
        
        # Verify user_id matches session
        if session_data.get("user_id") != user_id:
            raise HTTPException(
                status_code=401,
                detail="Session user mismatch"
            )
        
        # Get user from database to ensure they're still active
        try:
            user_obj_id = PydanticObjectId(user_id)
        except Exception:
            raise HTTPException(
                status_code=401,
                detail="Invalid user ID format"
            )
        
        user = await get_user_by_id(db, user_obj_id)
        if not user or not user.is_active:
            raise HTTPException(
                status_code=401,
                detail="User not found or inactive"
            )
        
        # Generate short-lived JWT for API access
        jwt_token = create_access_token(
            data={
                "sub": str(user.id),
                "email": user.email,
                "type": "session"
            },
            expires_delta=timedelta(minutes=60)  # 1 hour
        )
        
        return {
            "jwt": jwt_token
        }
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"Token creation error: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(
            status_code=500,
            detail="Failed to create session token"
        )


@router.get("/v1/me")
async def get_user_me(
    authorization: Optional[str] = Header(None),
    db: AsyncIOMotorDatabase = Depends(get_database)
):
    """
    Get current user information using client token.
    
    This endpoint returns user information in Clerk-compatible format.
    
    Parameters:
    - Authorization header: Bearer {client_token}
    
    Returns:
    - response: User data in Clerk format
    """
    try:
        # Extract and verify token from Authorization header
        if not authorization or not authorization.startswith("Bearer "):
            raise HTTPException(
                status_code=401,
                detail="Missing or invalid authorization header"
            )
        
        token = authorization.replace("Bearer ", "")
        
        # Verify token (can be either client or session token)
        token_payload = verify_token(token)
        if not token_payload:
            raise HTTPException(
                status_code=401,
                detail="Invalid token"
            )
        
        user_id = token_payload.get("sub")
        if not user_id:
            raise HTTPException(
                status_code=401,
                detail="Invalid token payload"
            )
        
        # Get user from database
        try:
            user_obj_id = PydanticObjectId(user_id)
        except Exception:
            raise HTTPException(
                status_code=401,
                detail="Invalid user ID format"
            )
        
        user = await get_user_by_id(db, user_obj_id)
        if not user or not user.is_active:
            raise HTTPException(
                status_code=401,
                detail="User not found or inactive"
            )
        
        # Return user info in Clerk-compatible format
        return {
            "response": {
                "id": str(user.id),
                "first_name": None,  # We don't store first/last name separately
                "last_name": None,
                "email_addresses": [
                    {
                        "id": str(user.id),
                        "email_address": user.email
                    }
                ],
                "primary_email_address_id": str(user.id),
                "image_url": None,  # Can add profile picture support later
                "public_metadata": {}
            }
        }
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"Get user error: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(
            status_code=500,
            detail="Failed to get user information"
        )


@router.get("/v1/me/organization_memberships")
async def get_organization_memberships(
    authorization: Optional[str] = Header(None),
    db: AsyncIOMotorDatabase = Depends(get_database)
):
    """
    Get user's organization memberships.
    
    Currently returns empty array as we don't have organization support yet.
    Can be implemented later when organization features are added.
    
    Parameters:
    - Authorization header: Bearer {client_token}
    
    Returns:
    - response: Array of organization memberships (empty for now)
    """
    try:
        # Extract and verify token from Authorization header
        if not authorization or not authorization.startswith("Bearer "):
            raise HTTPException(
                status_code=401,
                detail="Missing or invalid authorization header"
            )
        
        token = authorization.replace("Bearer ", "")
        
        # Verify token
        token_payload = verify_token(token)
        if not token_payload:
            raise HTTPException(
                status_code=401,
                detail="Invalid token"
            )
        
        # Return empty array for now (can implement organization support later)
        return {
            "response": []
        }
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"Get organization memberships error: {e}")
        raise HTTPException(
            status_code=500,
            detail="Failed to get organization memberships"
        )


@router.post("/v1/client/sessions/{session_id}/remove")
async def remove_session(
    session_id: str,
    authorization: Optional[str] = Header(None),
    redis_client = Depends(get_redis)
):
    """
    Remove (logout) a session.
    
    This endpoint is called by the VS Code extension during logout.
    
    Parameters:
    - session_id: The session ID to remove
    - Authorization header: Bearer {client_token}
    
    Returns:
    - Success response
    """
    try:
        # Extract and verify token from Authorization header
        if not authorization or not authorization.startswith("Bearer "):
            raise HTTPException(
                status_code=401,
                detail="Missing or invalid authorization header"
            )
        
        token = authorization.replace("Bearer ", "")
        
        # Verify token
        token_payload = verify_token(token)
        if not token_payload:
            raise HTTPException(
                status_code=401,
                detail="Invalid token"
            )
        
        # Delete session from Redis
        session_key = f"extension:session:{session_id}"
        redis_client.delete(session_key)
        
        return {
            "response": {
                "removed": True
            }
        }
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"Remove session error: {e}")
        raise HTTPException(
            status_code=500,
            detail="Failed to remove session"
        )


class ClerkToTicketRequest(BaseModel):
    """Request model for exchanging Clerk token for extension ticket."""
    state: str
    auth_redirect: str


@router.post("/extension/clerk-to-ticket")
async def clerk_to_ticket(
    request: ClerkToTicketRequest,
    authorization: Optional[str] = Header(None),
    redis_client = Depends(get_redis),
    db: AsyncIOMotorDatabase = Depends(get_database)
):
    """
    Exchange Clerk session token for extension ticket.
    
    This endpoint is called by the frontend when a user is already signed in with Clerk
    and wants to authenticate the VS Code extension.
    
    Parameters:
    - Authorization header: Bearer {clerk_token}
    - state: CSRF protection token from extension
    - auth_redirect: The VS Code URI to redirect back to
    
    Returns:
    - ticket: Authorization ticket to pass to extension
    """
    try:
        # Extract and verify Clerk token from Authorization header
        if not authorization or not authorization.startswith("Bearer "):
            raise HTTPException(
                status_code=401,
                detail="Missing or invalid authorization header"
            )
        
        token = authorization.replace("Bearer ", "")
        
        # Verify token
        token_payload = verify_token(token)
        if not token_payload:
            raise HTTPException(
                status_code=401,
                detail="Invalid token"
            )
        
        user_id = token_payload.get("sub")
        if not user_id:
            raise HTTPException(
                status_code=401,
                detail="Invalid token payload"
            )
        
        # Get user from database
        try:
            user_obj_id = PydanticObjectId(user_id)
        except Exception:
            raise HTTPException(
                status_code=401,
                detail="Invalid user ID format"
            )
        
        user = await get_user_by_id(db, user_obj_id)
        if not user or not user.is_active:
            raise HTTPException(
                status_code=401,
                detail="User not found or inactive"
            )
        
        # Generate authorization ticket
        ticket = secrets.token_urlsafe(32)
        
        # Store ticket with user data in Redis (5 minute expiry)
        ticket_data = {
            "user_id": str(user.id),
            "email": user.email,
            "created_at": datetime.utcnow().isoformat()
        }
        redis_client.setex(
            f"extension:ticket:{ticket}",
            300,  # 5 minutes
            json.dumps(ticket_data)
        )
        
        return {
            "ticket": ticket,
            "state": request.state,
            "auth_redirect": request.auth_redirect
        }
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"Clerk to ticket error: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(
            status_code=500,
            detail="Failed to generate ticket"
        )
